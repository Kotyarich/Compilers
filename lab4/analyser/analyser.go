package analyser

import (
	"fmt"
)

// Матрица предшествования
var matrix = map[string]map[string]string{
	"^":  {"^": ">", "n": "<", "i": "<", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"n":  {"^": ">", "n": " ", "i": " ", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": " ", ")": ">", "$": ">"},
	"i":  {"^": ">", "n": " ", "i": " ", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": " ", ")": ">", "$": ">"},
	"+":  {"^": "<", "n": "<", "i": "<", "+": ">", "-": ">", "*": "<", "/": "<", "%": "<", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"-":  {"^": "<", "n": "<", "i": "<", "+": ">", "-": ">", "*": "<", "/": "<", "%": "<", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"*":  {"^": "<", "n": "<", "i": "<", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"/":  {"^": "<", "n": "<", "i": "<", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"%":  {"^": "<", "n": "<", "i": "<", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": "<", ")": ">", "$": ">"},
	"<":  {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	"<=": {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	"=":  {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	">=": {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	">":  {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	"<>": {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": " ", "$": ">"},
	"(":  {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": " ", "<=": " ", "=": " ", ">=": " ", ">": " ", "<>": " ", "(": "<", ")": "=", "$": " "},
	")":  {"^": ">", "n": " ", "i": " ", "+": ">", "-": ">", "*": ">", "/": ">", "%": ">", "<": ">", "<=": ">", "=": ">", ">=": ">", ">": ">", "<>": ">", "(": " ", ")": ">", "$": ">"},
	"$":  {"^": "<", "n": "<", "i": "<", "+": "<", "-": "<", "*": "<", "/": "<", "%": "<", "<": "<", "<=": "<", "=": "<", ">=": "<", ">": "<", "<>": "<", "(": "<", ")": " ", "$": " "},
}

// Правила остовной грамматики
var rules = map[string]struct{}{
	"E<E":  {},
	"E<=E": {},
	"E=E":  {},
	"E>=E": {},
	"E>E":  {},
	"E<>E": {},
	"E":    {},
	"+E":   {},
	"-E":   {},
	"E+E":  {},
	"E-E":  {},
	"E*E":  {},
	"E/E":  {},
	"E%E":  {},
	"E^E":  {},
	"n":    {},
	"i":    {},
	"(E)":  {},
}

type stackItem struct {
	value      string
	expression string
}

type Analyser struct {
	curSymbol string
	stack     []stackItem
	reader    reader
}

func NewAnalyser(reader reader) *Analyser {
	return &Analyser{
		reader: reader,
		stack:  make([]stackItem, 0),
	}
}

func (a *Analyser) Analyse() (string, bool) {
	a.stack = append(a.stack, stackItem{"$", "$"})
	a.curSymbol, _ = a.reader.Next()

	for {
		terminal, err := a.getTopNonTerminal()
		if err != nil {
			return "", false
		}

		if terminal == "$" && a.curSymbol == "$" {
			return a.stack[1].expression, true
		}

		relation := matrix[terminal][a.curSymbol]
		switch relation {
		case "<", "=":
			err = a.shift()
			if err != nil {
				return "", false
			}
		case ">":
			err = a.convolution()
			if err != nil {
				return "", false
			}
		case " ":
			return "", false
		}
	}
}

func (a *Analyser) shift() error {
	a.stack = append(a.stack, stackItem{a.curSymbol, a.curSymbol})
	a.curSymbol, _ = a.reader.Next()

	return nil
}

func (a *Analyser) convolution() error {
	var prevSymbol *string
	chain := ""
	expressions := make([]string, 0, 3)

	i := len(a.stack) - 1
	for ; i >= 0; i-- {
		// Скипаем нетерминалы на верхушке стека
		if a.stack[i].value == "E" {
			expressions = append([]string{a.stack[i].expression}, expressions...)
		} else {
			// Запоминаем первый нетерминал
			if prevSymbol == nil {
				prevSymbol = &a.stack[i].value
			} else {
				relation := matrix[a.stack[i].value][*prevSymbol]
				if relation == "=" {
					// Собираем нетерминалы, связанные равенством
					*prevSymbol = a.stack[i].value
				} else {
					break
				}
			}
		}
		chain = a.stack[i].value + chain
	}

	_, ok := rules[chain]
	if !ok {
		return fmt.Errorf("rule '%s' not found", chain)
	}

	expr, ok := handleExpression(expressions, *prevSymbol)
	if !ok {
		expr = chain
	}

	a.stack = append(a.stack[:i+1], stackItem{"E", expr})
	return nil
}


func (a *Analyser) getTopNonTerminal() (string, error) {
	for i := len(a.stack) - 1; i >= 0; i-- {
		if a.stack[i].value != "E" {
			return a.stack[i].value, nil
		}
	}

	return "", fmt.Errorf("empty stack error")
}
